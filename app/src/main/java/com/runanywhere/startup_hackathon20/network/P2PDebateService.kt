package com.runanywhere.startup_hackathon20.network

import android.util.Log
import com.runanywhere.startup_hackathon20.DebateMessage
import com.runanywhere.startup_hackathon20.TopicGenerator
import io.github.jan.supabase.postgrest.from
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import java.util.UUID

/**
 * P2P Debate Service
 * Handles all database operations for player-vs-player debates
 */
class P2PDebateService {

    private val supabase = SupabaseConfig.client
    private val TAG = "P2PDebateService"

    /**
     * Data classes for Supabase interaction
     */

    /**
     * For creating new P2P sessions (insert)
     */
    @Serializable
    data class P2PSessionInsert(
        @SerialName("session_id")
        val sessionId: String,

        @SerialName("topic_id")
        val topicId: String,

        @SerialName("topic_title")
        val topicTitle: String,

        @SerialName("topic_description")
        val topicDescription: String,

        @SerialName("player1_id")
        val player1Id: String,

        @SerialName("player1_name")
        val player1Name: String,

        @SerialName("player1_side")
        val player1Side: String,

        @SerialName("player2_id")
        val player2Id: String,

        @SerialName("player2_name")
        val player2Name: String,

        @SerialName("player2_side")
        val player2Side: String,

        @SerialName("status")
        val status: String,

        @SerialName("current_turn")
        val currentTurn: String,

        @SerialName("turn_number")
        val turnNumber: Int,

        @SerialName("prep_time_remaining")
        val prepTimeRemaining: Int,

        @SerialName("debate_time_remaining")
        val debateTimeRemaining: Long
    )

    /**
     * For reading P2P sessions (select)
     */
    @Serializable
    data class P2PSessionResponse(
        @SerialName("session_id")
        val session_id: String,

        @SerialName("topic_id")
        val topic_id: String,

        @SerialName("topic_title")
        val topic_title: String,

        @SerialName("topic_description")
        val topic_description: String? = null,

        @SerialName("player1_id")
        val player1_id: String,

        @SerialName("player1_name")
        val player1_name: String,

        @SerialName("player1_side")
        val player1_side: String,

        @SerialName("player2_id")
        val player2_id: String,

        @SerialName("player2_name")
        val player2_name: String,

        @SerialName("player2_side")
        val player2_side: String,

        @SerialName("status")
        val status: String,

        @SerialName("current_turn")
        val current_turn: String,

        @SerialName("turn_number")
        val turn_number: Int,

        @SerialName("prep_time_remaining")
        val prep_time_remaining: Int,

        @SerialName("debate_time_remaining")
        val debate_time_remaining: Long,

        @SerialName("start_time")
        val start_time: String? = null,

        @SerialName("end_time")
        val end_time: String? = null,

        @SerialName("created_at")
        val created_at: String? = null,

        @SerialName("updated_at")
        val updated_at: String? = null
    )

    @Serializable
    data class P2PMessageResponse(
        @SerialName("id")
        val id: String,

        @SerialName("session_id")
        val session_id: String,

        @SerialName("player_id")
        val player_id: String,

        @SerialName("player_name")
        val player_name: String,

        @SerialName("message")
        val message: String,

        @SerialName("turn_number")
        val turn_number: Int,

        @SerialName("timestamp")
        val timestamp: String,

        @SerialName("word_count")
        val word_count: Int? = null
    )

    @Serializable
    data class P2PMessageInsert(
        @SerialName("id")
        val id: String,

        @SerialName("session_id")
        val sessionId: String,

        @SerialName("player_id")
        val playerId: String,

        @SerialName("player_name")
        val playerName: String,

        @SerialName("message")
        val message: String,

        @SerialName("turn_number")
        val turnNumber: Int
        // timestamp and word_count auto-generated by database
    )

    /**
     * Create a new P2P debate session
     * Called by matchmaking service when two players are matched
     */
    suspend fun createSession(
        player1Id: String,
        player1Name: String,
        player2Id: String,
        player2Name: String
    ): Result<String> = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üéÆ Creating P2P session: $player1Name vs $player2Name")

            // 1. Generate random topic (same as AI mode!)
            val (topic, _) = TopicGenerator.generateDynamicTopic()
            Log.d(TAG, "üìú Generated topic: ${topic.title}")

            // 2. Random side assignment
            val player1Side = listOf("FOR", "AGAINST").random()
            val player2Side = if (player1Side == "FOR") "AGAINST" else "FOR"
            Log.d(TAG, "‚öîÔ∏è Sides: $player1Name = $player1Side, $player2Name = $player2Side")

            // 3. Random first turn (replaces coin toss!)
            val firstTurn = listOf(player1Id, player2Id).random()
            val starterName = if (firstTurn == player1Id) player1Name else player2Name
            Log.d(TAG, "üé≤ First turn: $starterName ($firstTurn)")

            // 4. Create session ID
            val sessionId = UUID.randomUUID().toString()

            // 5. Insert into database
            val sessionData = P2PSessionInsert(
                sessionId = sessionId,
                topicId = topic.id.toString(),
                topicTitle = topic.title,
                topicDescription = (topic.description ?: ""),
                player1Id = player1Id,
                player1Name = player1Name,
                player1Side = player1Side,
                player2Id = player2Id,
                player2Name = player2Name,
                player2Side = player2Side,
                status = "PREP",
                currentTurn = firstTurn,
                turnNumber = 0,
                prepTimeRemaining = 30,
                debateTimeRemaining = 900000L
            )

            supabase.from("debate_sessions_p2p").insert(sessionData)

            Log.d(TAG, "‚úÖ P2P session created successfully: $sessionId")
            Result.success(sessionId)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error creating P2P session", e)
            Result.failure(e)
        }
    }

    /**
     * Get session details by ID
     */
    suspend fun getSession(sessionId: String): Result<P2PSessionResponse> =
        withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "üì• Fetching session: $sessionId")

                val response = supabase.from("debate_sessions_p2p")
                    .select {
                        filter {
                            eq("session_id", sessionId)
                        }
                    }
                    .decodeSingle<P2PSessionResponse>()

                Log.d(TAG, "‚úÖ Session fetched: ${response.topic_title}")
                Result.success(response)

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error fetching session", e)
                Result.failure(e)
            }
        }

    /**
     * Update session status (PREP ‚Üí IN_PROGRESS ‚Üí FINISHED)
     */
    suspend fun updateSessionStatus(
        sessionId: String,
        newStatus: String
    ): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üîÑ Updating session status to: $newStatus")

            supabase.from("debate_sessions_p2p")
                .update({
                    set("status", newStatus)
                }) {
                    filter {
                        eq("session_id", sessionId)
                    }
                }

            Log.d(TAG, "‚úÖ Session status updated")
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error updating session status", e)
            Result.failure(e)
        }
    }

    /**
     * Update current turn (switches between players)
     */
    suspend fun updateTurn(
        sessionId: String,
        nextPlayerId: String,
        turnNumber: Int
    ): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üîÑ Switching turn to: $nextPlayerId (Turn #$turnNumber)")

            supabase.from("debate_sessions_p2p")
                .update({
                    set("current_turn", nextPlayerId)
                    set("turn_number", turnNumber)
                }) {
                    filter {
                        eq("session_id", sessionId)
                    }
                }

            Log.d(TAG, "‚úÖ Turn updated")
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error updating turn", e)
            Result.failure(e)
        }
    }

    /**
     * Send a message in the debate
     */
    suspend fun sendMessage(
        sessionId: String,
        playerId: String,
        playerName: String,
        message: String,
        turnNumber: Int
    ): Result<String> = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üì§ Sending message from $playerName (Turn $turnNumber)")

            val messageId = UUID.randomUUID().toString()
            val messageData = P2PMessageInsert(
                id = messageId,
                sessionId = sessionId,
                playerId = playerId,
                playerName = playerName,
                message = message,
                turnNumber = turnNumber
            )

            supabase.from("debate_messages_p2p").insert(messageData)

            Log.d(TAG, "‚úÖ Message sent successfully")
            Result.success(messageId)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error sending message", e)
            Result.failure(e)
        }
    }

    /**
     * Get all messages for a session (ordered by timestamp)
     */
    suspend fun getMessages(sessionId: String): Result<List<DebateMessage>> =
        withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "üì• Fetching messages for session: $sessionId")

                val response = supabase.from("debate_messages_p2p")
                    .select {
                        filter {
                            eq("session_id", sessionId)
                        }
                    }
                    .decodeList<P2PMessageResponse>()

                // Convert to DebateMessage and sort by timestamp
                val messages = response.map { msg ->
                    DebateMessage(
                        id = msg.id,
                        playerId = msg.player_id,
                        playerName = msg.player_name,
                        message = msg.message,
                        timestamp = msg.timestamp.toLongOrNull() ?: System.currentTimeMillis(),
                        turnNumber = msg.turn_number
                    )
                }.sortedBy { it.timestamp }

                Log.d(TAG, "‚úÖ Fetched ${messages.size} messages")
                Result.success(messages)

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error fetching messages", e)
                Result.failure(e)
            }
        }

    /**
     * Poll for new messages (backup if real-time fails)
     * Returns messages with turn_number > lastSeenTurnNumber
     */
    suspend fun pollNewMessages(
        sessionId: String,
        lastSeenTurnNumber: Int
    ): Result<List<DebateMessage>> = withContext(Dispatchers.IO) {
        try {
            val response = supabase.from("debate_messages_p2p")
                .select {
                    filter {
                        eq("session_id", sessionId)
                        gt("turn_number", lastSeenTurnNumber)
                    }
                }
                .decodeList<P2PMessageResponse>()

            val messages = response.map { msg ->
                DebateMessage(
                    id = msg.id,
                    playerId = msg.player_id,
                    playerName = msg.player_name,
                    message = msg.message,
                    timestamp = msg.timestamp.toLongOrNull() ?: System.currentTimeMillis(),
                    turnNumber = msg.turn_number
                )
            }.sortedBy { it.timestamp }

            if (messages.isNotEmpty()) {
                Log.d(TAG, "üì¨ Polled ${messages.size} new messages")
            }

            Result.success(messages)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error polling messages", e)
            Result.failure(e)
        }
    }

    /**
     * Check if session status changed (for prep ‚Üí in_progress transition)
     */
    suspend fun pollSessionStatus(sessionId: String): Result<String> =
        withContext(Dispatchers.IO) {
            try {
                val response = supabase.from("debate_sessions_p2p")
                    .select {
                        filter {
                            eq("session_id", sessionId)
                        }
                    }
                    .decodeSingle<P2PSessionResponse>()

                Result.success(response.status)

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error polling session status", e)
                Result.failure(e)
            }
        }

    /**
     * Check whose turn it is (for UI updates)
     */
    suspend fun pollCurrentTurn(sessionId: String): Result<Pair<String, Int>> =
        withContext(Dispatchers.IO) {
            try {
                val response = supabase.from("debate_sessions_p2p")
                    .select {
                        filter {
                            eq("session_id", sessionId)
                        }
                    }
                    .decodeSingle<P2PSessionResponse>()

                Result.success(Pair(response.current_turn, response.turn_number))

            } catch (e: Exception) {
                Log.e(TAG, "‚ùå Error polling current turn", e)
                Result.failure(e)
            }
        }

    /**
     * End debate session
     */
    suspend fun endSession(sessionId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üèÅ Ending session: $sessionId")

            supabase.from("debate_sessions_p2p")
                .update({
                    set("status", "FINISHED")
                }) {
                    filter {
                        eq("session_id", sessionId)
                    }
                }

            Log.d(TAG, "‚úÖ Session ended")
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error ending session", e)
            Result.failure(e)
        }
    }

    /**
     * Delete session and all messages (cleanup)
     */
    suspend fun deleteSession(sessionId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "üóëÔ∏è Deleting session: $sessionId")

            // Messages will auto-delete due to CASCADE foreign key
            supabase.from("debate_sessions_p2p")
                .delete {
                    filter {
                        eq("session_id", sessionId)
                    }
                }

            Log.d(TAG, "‚úÖ Session deleted")
            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error deleting session", e)
            Result.failure(e)
        }
    }

    /**
     * Get opponent info for current player
     */
    suspend fun getOpponentInfo(
        sessionId: String,
        currentPlayerId: String
    ): Result<Pair<String, String>> = withContext(Dispatchers.IO) {
        try {
            val session = getSession(sessionId).getOrThrow()

            val (opponentId, opponentName) = if (currentPlayerId == session.player1_id) {
                Pair(session.player2_id, session.player2_name)
            } else {
                Pair(session.player1_id, session.player1_name)
            }

            Result.success(Pair(opponentId, opponentName))

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error getting opponent info", e)
            Result.failure(e)
        }
    }
}
